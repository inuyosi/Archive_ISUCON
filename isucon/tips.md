- 外部コマンド実行ではなく、ライブラリを利用する
  - 外部コマンドを使っている場所があれば。ライブラリ実装できないか検討する
- 開発用の設定で冗長なログを出力しない
  - 各アプリケーションのデバックモード、ログレベルを確認する
- HTTPクライアントの使い方
  - 同一ホストへのコネクションを使い回す
    -   ハンドシェイク処理を少なくする
  - 適切なタイムアウトを設定する
  -   データの更新をしないGETリクエスト: 短めのタイムアウト
  -   データを更新するPOSTリクエスト: 長めのタイムアウト
  - 同一ホストに大量のリクエストを送る場合、対象ホストへのコネクション数の制限を確認する
    - 大き目の値(ex. 200)にすると良い
- 静的ファイル配信をリバースプロキシから直接配信する
  - アンチパターン
    - MySQLから大きなデータの読み込みはメモリやネットワーク帯域をひっ迫する
    - 画像データがアプリケーションサーバのメモリに乗せることを避ける
    - 画像データを配信するまで、アプリケーションサーバの処理が続かないようにする
  - try-files: パラメータに指定したファイルパスを前から順番にチェックしファイルがあれば、そのファイルの内容をレスポンスとして返し、どのファイルも存在しなかった場合は最後に指定した転送先URIへ内部リダイレクトを行う設定
  - アプリケーションサーバから直接ファイルを配信せず、リバースプロキシから配信する構成にする。
  - アプリケーションの使用にが画像ファイルの変更が含まれる場合: URLも同時に変更すること
    - CDNのキャッシュの削除が難しいため
    - クエリ文字列を使用することも有効
      - キャッシュバスター: 注意点あり
        - サーバのキャッシュキーに食えり文字れるが含まれている
        - ファイルが変更されたら必ずクエリ文字列を渡す値を更新する
        - ファイルが変更されていないなら同じクエリ文字列を使い続けることでキャッシュの更新を最低限にする
- HTTPヘッダを活用してクライアント側にキャッシュさせる
  - Cache-Controlヘッダ
  - Last-Modified・ETagヘッダ
    - Last-Modifiedヘッダで十分、ETagは無効に
- CDN上にHTTPレスポンスをキャッシュする
  - CDNの機能
    - 柔軟なキャッシュ設定
    - アクセスログなどのログ保存
    - HTTPのリクエスト・レスポンスの書き換え
    - DDoS対策
    - Web Application Firewall
  - Cache-Controlを活用してCDNやProxy上にキャッシュさせる
    - CDN-Cache-Control
    - 課題
      - CDNの挙動に対して詳しくなければキャッシュしてはいけないレスポンスをキャッシュするなどの事故を起こしやすい
        - キャッシュを使うHTTPメソッド
        - Set-Cookieヘッダ  
      - アプリケーションの設計をキャッシュが活用しやすい設計にする必要があるので難易度が高い
  - クラウド事業者のオブジェクトストレージサービスを利用する
    - 確認点
      - Content-Typeはどう決まるのか
        - `X-Content-Type-Options: nosniff`の付与
      - gzip圧縮できるコンテンツの場合、gzip圧縮されているか
        - 既に圧縮されているファイル形式は圧縮しない  
      - Cache-Controlヘッダの設定はどうするのか
      - CDNを前段に入れる場合、gzip圧縮やCache-Control周りがそれぞれどう動くのか    
